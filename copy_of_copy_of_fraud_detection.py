# -*- coding: utf-8 -*-
"""Copy of Copy of Fraud Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/185dFFi9zkSGjC04_I725ckTLVfyAeMsT

# Importing Libraries & Loading the Dataset
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from imblearn.under_sampling import RandomUnderSampler
from sklearn.model_selection import train_test_split, GridSearchCV
import numpy as np

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report,confusion_matrix,accuracy_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier

df = pd.read_csv('/content/drive/MyDrive/Capstone Project (Data Science- BIA)/Fraud_Analysis_Dataset.csv')

"""# Attribute Info

step - maps a unit of time in the real world. In this case 1 step is 1 hour of time.

type - CASH-IN, CASH-OUT, DEBIT, PAYMENT and TRANSFER.

amount - amount of the transaction in local currency.

nameOrig - customer who started the transaction

oldbalanceOrg - initial balance before the transaction

newbalanceOrig - new balance after the transaction.

nameDest - customer who is the recipient of the transaction

oldbalanceDest - initial balance recipient before the transaction. Note that there is not information for customers that start with M (Merchants).

newbalanceDest - new balance recipient after the transaction. Note that there is not information for customers that start with M (Merchants).

isFraud - This is the transactions made by the fraudulent agents inside the simulation. In this specific dataset the fraudulent behavior of the agents aims to profit by taking control or customers accounts and try to empty the funds by transferring to another account and then cashing out of the system.

**Column Value Information**

CASH-IN: Refers to depositing cash into an account, typically adding funds.

CASH-OUT: Refers to withdrawing cash from an account, usually removing funds.

DEBIT: This can have two meanings:

It can refer to a decrease in the balance of a financial account due to a withdrawal or an expense.

In accounting, it represents an entry that reduces assets or increases liabilities.

PAYMENT: Refers to the transfer of money from one party (payer) to another (payee) in exchange for goods, services, or as settlement of a debt.

TRANSFER: Refers to moving money from one account to another, often between accounts held by the same person or entity.

# EDA and Preprocessing
"""

df.head()

"""Used df.head() to get an idea about the attributes(columns)"""

df.shape

"""There are 11142 rows and 10 columns in the given data set"""

df.columns

"""We analyze the columns whether they are independent or dependent, whether they are required for training or should we simply drop them...."""

df.isna().sum()

"""data is clean (There are no missing values)"""

df.dtypes

"""there are 3 categorical features and 6 (indpendent) numerical features and isFraud is dependent

"""

df.describe()

sns.countplot(x='type', data=df)
plt.title('Distribution of different types of Transactions')

"""We check the distribution of different types of Transactions"""

sns.countplot(x='isFraud', data=df)
plt.title('Number of Fraudulent vs Non-Fraudulent Transactions')

"""Here we can clearly see that there is a imbalance in the data.

We have less number of datapoints for Fraudulent Transactions (1142) as compared to the Non Fraudulent ones (10000)


hence to handle this data imbalance we'll be using under sampling
"""

sns.histplot(data=df, x='amount', hue='isFraud', element='step', log_scale=True)

"""We can clearly see that the Frauds involve a higher amount(10^4 -10^7) as compared to Non-Fraudulent ones

Or we can also say that when the transaction amounts are big the probability of it being a Fraud is comparatively more
"""

sns.lineplot(x='step', y='isFraud', data=df)

"""we can observe that there is a sudden jump in frauds after a particular step value"""

sns.countplot(x='type', hue='isFraud', data=df)

"""we can see that all of the Fraud transactions belong to Transaction types 'TRANSFER' and 'CASH_OUT'"""

sns.boxplot(x='isFraud', y='oldbalanceOrg', data=df)
plt.yscale('log')     # as the amounts are quite big we need to use "log" for proper visualization

"""There are some outliers in the data

Outliers can be found using turkey fence (< Q1 - 1.5 IQR or > Q3+ 1.5 IQR)
"""

df.drop(['nameOrig', 'nameDest'], axis=1, inplace=True)

"""We drop 2 attributes ('nameOrig','nameDest') that are not required for decision making"""

X=df.iloc[:,:-1]
y=df.iloc[:,-1]

"""X = independent attributes
y = dependent attribute

## Encoding
"""

label_encoder = LabelEncoder()
X['type'] = label_encoder.fit_transform(X['type'])

y_encoded = label_encoder.fit_transform(y)

"""We use encoding to convert the categorical attributes in the "type" column to numerical.

reason- to avoid sparsity

## Class-balancing
"""

UnderSampled=RandomUnderSampler(random_state=42)

y_discretized = pd.cut(y, bins=4, labels=False)
X_resampled, y_resampled = UnderSampled.fit_resample(X, y_discretized)

"""We use under sampling as there was data imbalance."""

y_resampled_series = pd.Series(y_resampled)
value_counts = y_resampled_series.value_counts()

print(value_counts)

"""we check no. of fraud and non-fraud datapoints in the undersampled data to ensure that there is no bias in the undersampled data"""

corr_matrix = X_resampled.corr()
sns.heatmap(corr_matrix, annot=True)

"""we can see that there are strong correlations b/w a few pair of attributes.



1.  oldbalanceOrg and newbalanceOrig has a correlation of +0.69

*   if the difference in balances is not as expected, it may indicate fraud

2.   oldbalanceDest and newbalanceDest has a correlation of +0.84

*   this also means that if difference in balances is not as expected it might be a Fraud Transaction

3.  amount and oldbalanceOrg has a correlation of +0.71


*   Larger amount of transactions are usually done accounts having high balances

## Feature Engineering
"""

df['balanceOrigDiff'] = df['oldbalanceOrg'] - df['newbalanceOrig']
df['balanceDestDiff'] = df['oldbalanceDest'] - df['newbalanceDest']

"""We add two new features

1.   'balanceOrigDiff'
2.   'balanceDestDiff'

these show the difference in the balances before and after the Transaction
"""

df["amount_to_orig_balance_ratio"] = df["amount"] / (df["oldbalanceOrg"] + 1)
df["amount_to_dest_balance_ratio"] = df["amount"] / (df["oldbalanceDest"] + 1)

"""We add two new features
1. "amount_to_orig_balance_ratio"
2. "amount_to_dest_balance_ratio"
these show the impact on the ratio of balances before and after the Transaction
"""

df["fraud_risk_score"] = np.log1p(df["amount"]) * df["amount_to_orig_balance_ratio"]

"""We add new feature "fraud_risk_score" which is Probability of Fraud based on Transaction Amount and the change in ratio of account Balance"""

df.head()

sns.histplot(data=df, x='balanceOrigDiff', hue='isFraud', log_scale=True)

"""we can see that if the difference in balance is big (on the sender's side) there are higher chances of it being a Fraud Transaction"""

sns.histplot(data=df, x='balanceDestDiff', hue='isFraud', log_scale=True)

"""There is no particular pattern here"""

sns.pairplot(df[['amount', 'oldbalanceOrg', 'newbalanceOrig', 'isFraud']], hue='isFraud')

"""# Splitting Data into Training and Testing"""

X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.2, random_state=42, stratify=y_resampled)

"""We use 80% of the data for training the model and 20% of the data to test the model

# Logistic Regression Model
"""

logreg=LogisticRegression()

logreg.fit(X_train,y_train)

y_pred=logreg.predict(X_test)

print(classification_report(y_test,y_pred))

param_grid = {
    'C': [0.01, 0.1, 1, 10],  # Regularization strength
    'solver': ['liblinear', 'lbfgs']
}

grid_search = GridSearchCV(logreg, param_grid, cv=5, scoring='accuracy', n_jobs=-1)
grid_search.fit(X_train, y_train)

best_logreg = grid_search.best_estimator_   # Best model from Grid Search

best_logreg.fit(X_train,y_train)

y_pred=best_logreg.predict(X_test)

print(classification_report(y_test,y_pred))

print(accuracy_score(y_test,y_pred))

"""After hyper parameter tuning model's accuracy increses to 92.12%

precision-93% (minimized false positives)
"""

print(confusion_matrix(y_test,y_pred))



"""# Other algorithms implemented

## Random Forest
"""

RanFo = RandomForestClassifier(random_state=42)

RanFo.fit(X_train, y_train)

y_pred = RanFo.predict(X_test)

print(classification_report(y_test,y_pred))

print(accuracy_score(y_test,y_pred))

print(confusion_matrix(y_test,y_pred))

"""as the model has overfitted hence we are getting a accuracy of 99.56%

## Gradient Boosting
"""

gb_model = GradientBoostingClassifier(random_state=42)

gb_model.fit(X_train, y_train)

y_pred_gb = gb_model.predict(X_test)

print(accuracy_score(y_test,y_pred_gb))

print(classification_report(y_test,y_pred))

"""as the model has overfitted hence we are getting a accuracy of 99.34%"""

print(confusion_matrix(y_test,y_pred_gb))

"""## Support Vector Machine"""

svm = SVC()

svm.fit(X_train, y_train)

y_pred = svm.predict(X_test)

print(classification_report(y_test, y_pred))

print(accuracy_score(y_test, y_pred))

print(confusion_matrix(y_test, y_pred))



"""## KNN"""

knn = KNeighborsClassifier(n_neighbors=8)

knn.fit(X_train, y_train)

y_pred = knn.predict(X_test)

print(accuracy_score(y_test, y_pred))

print(classification_report(y_test, y_pred))

print(confusion_matrix(y_test, y_pred))

"""# Conclusion

## Financial Impact Analysis

1.   Revenue from True Positive (TP): Correctly identified fraudulent transactions

*  Can be Calculated as the total amount of fraudulent transactions correctly detected.

2.   Cost of False Positive (FP): Legitimate transactions incorrectly flagged as fraudulent.

*    inconvenience or loss of business from incorrectly classifying legitimate transactions.


3.   Loss from False Negative (FN): Fraudulent transactions incorrectly classified as legitimate.

*    Financial loss from undetected fraudulent transactions.


4.   No impact of True Negatives (TN): Legitimate transactions correctly classified as non-fraudulent

*    These generally don‚Äôt have a direct financial impact (i.e., they neither cause a loss nor generate revenue)
*    These can still be useful for assessing the model's overall performance.

## Model performance

For Classification of the Transactions we have used 3 different models (as per the instructions).

1.   Logistic Regression (Accuracy-92.12%)
2.   Random Forests (Overfitting-99.56)
3.   Gradient Boosting (Overfitting-99.34%)
4.   Support Vector Machine (Accuracy 80.52%)
5.   K-Nearest Neighbors (Accuracy-92.77%)

Using Logistic Rgression for the given dataset we get a accuracy of 92.12%.

While for 'Random Forests' & 'Gradient boosting' we are getting  accuracies of 99.56%, 99.34% respectively which indicates that it is a condition of Overfitting.

Hence we will be using Logistic Regression.

other Models used are SVM and KNN.

though We get a accuracy of 92.77 using KNN we'll still use Logistic Regression as KNN was not mentioned in the Instructions (Project Description)
"""





"""# Deployment"""

import pickle

!pip install streamlit

import streamlit as st

# Save the trained model
with open('fraud_detection_model.pkl', 'wb') as file:
    pickle.dump(best_logreg, file)

!ls -l app.py

!cat app.py

!pip install streamlit
!wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O cloudflared
!chmod +x cloudflared

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pickle
# import pandas as pd
# 
# # Load the trained model
# with open('fraud_detection_model.pkl', 'rb') as file:
#     model = pickle.load(file)
# 
# st.markdown("""
#     <style>
#         .main {
#             background-color: #f5f7fa;
#         }
#         div.stButton > button {
#             background-color: #FF4B4B;
#             color: white;
#             font-size: 18px;
#             padding: 10px 24px;
#             border-radius: 10px;
#         }
#         div.stButton > button:hover {
#             background-color: #d43f3f;
#         }
#     </style>
# """, unsafe_allow_html=True)
# 
# # ---- Page Title ----
# st.markdown("<h1 style='text-align: center; color: #333;'>üí≥ Fraud Detection System</h1>", unsafe_allow_html=True)
# st.markdown("<h4 style='text-align: center; color: #555;'>Enter transaction details to detect fraud</h4>", unsafe_allow_html=True)
# 
# st.write("---")  # Horizontal line
# 
# # ---- Sidebar ----
# st.sidebar.image("https://cdn-icons-png.flaticon.com/512/2832/2832484.png", width=120)
# st.sidebar.markdown("### About")
# st.sidebar.info(
#     "This system helps detect fraudulent transactions based on machine learning. "
#     "Enter transaction details to check if a transaction is suspicious."
# )
# 
# st.sidebar.markdown("### How it Works?")
# st.sidebar.markdown("""
# 1Ô∏è‚É£ Enter transaction details
# 2Ô∏è‚É£ Click 'Check for Fraud'
# 3Ô∏è‚É£ Get instant fraud detection results
# """)
# 
# # ---- Layout: Two Column Design ----
# col1, col2 = st.columns(2)
# 
# with col1:
#     step = st.number_input("‚è≥ Step (Time in hours)", min_value=0, step=1)
#     transaction_type = st.selectbox("üí∞ Transaction Type", ["CASH-IN", "CASH-OUT", "DEBIT", "PAYMENT", "TRANSFER"])
#     amount = st.number_input("üíµ Transaction Amount", min_value=0.0, step=0.01)
# 
# with col2:
#     oldbalanceOrg = st.number_input("üè¶ Sender's Old Balance", min_value=0.0, step=0.01)
#     newbalanceOrig = st.number_input("üìâ Sender's New Balance", min_value=0.0, step=0.01)
#     oldbalanceDest = st.number_input("üìà Receiver's Old Balance", min_value=0.0, step=0.01)
#     newbalanceDest = st.number_input("üèß Receiver's New Balance", min_value=0.0, step=0.01)
# 
# # Convert transaction type to numeric (same as in training)
# type_mapping = {"CASH-IN": 0, "CASH-OUT": 1, "DEBIT": 2, "PAYMENT": 3, "TRANSFER": 4}
# transaction_type = type_mapping[transaction_type]
# 
# # Create a dataframe with correct feature names
# input_data = pd.DataFrame([[step, transaction_type, amount, oldbalanceOrg, newbalanceOrig, oldbalanceDest, newbalanceDest]],
#                           columns=['step', 'type', 'amount', 'oldbalanceOrg', 'newbalanceOrig', 'oldbalanceDest', 'newbalanceDest'])
# 
# # ---- Predict Fraud ----
# st.write("---")  # Horizontal line
# 
# st.markdown("<h3 style='text-align: center;'>üîç Click Below to Check for Fraud</h3>", unsafe_allow_html=True)
# 
# if st.button("üö® Check for Fraud"):
#     prediction = model.predict(input_data)[0]
# 
#     if prediction == 1:
#         st.error("‚ö†Ô∏è **Fraudulent Transaction Detected!**")
#         st.markdown("### üî¥ High Risk Transaction üö®")
#         st.markdown("This transaction appears to be fraudulent based on our machine learning model.")
#     else:
#         st.success("‚úÖ **Transaction is Legitimate!**")
#         st.markdown("### üü¢ Safe Transaction ‚úî")
#         st.markdown("No fraud detected. This transaction seems normal.")
# 
# st.write("---")  # Horizontal line
# 
# # ---- Footer ----
# st.markdown("<h5 style='text-align: center; color: #888;'>üîí Secure AI-Powered Fraud Detection | ¬© 2025</h5>", unsafe_allow_html=True)

!streamlit run app.py &>/dev/null &
!./cloudflared tunnel --url http://localhost:8501 --no-autoupdate

